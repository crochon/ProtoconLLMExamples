constant N := 5;  // Number of nodes
constant M := 4;  // Number of states for puppet variable x

variable t[Nat % N] <- Nat % 2;  // Binary token variable for each node
variable x[Nat % N] <- Nat % M;  // Puppet variable for each node

// Process Bot (operates on node 0)
process Bot[i <- Nat % 1]
{
  read: t[i-1];
  read: x[i-1];
  write: t[i];
  write: x[i];
  direct action:
    // Define transitions for Bot process based on t[i-1], x[i-1], t[i], x[i]
    ( t[i-1]==0 && x[i-1]==0 && t[i]==0 && x[i]==0 --> t[i]:=0; x[i]:=2; )
    ( t[i-1]==0 && x[i-1]==0 && t[i]==1 && x[i]==0 --> t[i]:=1; x[i]:=2; )
    ( t[i-1]==0 && x[i-1]==0 && t[i]==1 && x[i]==1 --> t[i]:=1; x[i]:=2; )
    ( t[i-1]==0 && x[i-1]==1 && t[i]==0 && x[i]==0 --> t[i]:=0; x[i]:=2; )
    ( t[i-1]==0 && x[i-1]==1 && t[i]==0 && x[i]==1 --> t[i]:=1; x[i]:=2; )
    ( t[i-1]==0 && x[i-1]==1 && t[i]==1 && x[i]==0 --> t[i]:=1; x[i]:=2; )
    ( t[i-1]==0 && x[i-1]==1 && t[i]==1 && x[i]==1 --> t[i]:=1; x[i]:=2; )
    ( t[i-1]==0 && x[i-1]==2 && t[i]==0 && x[i]==0 --> t[i]:=1; x[i]:=0; )
    ( t[i-1]==0 && x[i-1]==2 && t[i]==0 && x[i]==1 --> t[i]:=1; x[i]:=1; )
    ( t[i-1]==0 && x[i-1]==2 && t[i]==0 && x[i]==2 --> t[i]:=1; x[i]:=0; )
    ( t[i-1]==0 && x[i-1]==2 && t[i]==1 && x[i]==2 --> t[i]:=1; x[i]:=0; )
    ( t[i-1]==1 && x[i-1]==0 && t[i]==0 && x[i]==0 --> t[i]:=0; x[i]:=1; )
    ( t[i-1]==1 && x[i-1]==0 && t[i]==1 && x[i]==0 --> t[i]:=0; x[i]:=2; )
    ( t[i-1]==1 && x[i-1]==0 && t[i]==1 && x[i]==1 --> t[i]:=0; x[i]:=1; )
    ( t[i-1]==1 && x[i-1]==1 && t[i]==0 && x[i]==0 --> t[i]:=0; x[i]:=1; )
    ( t[i-1]==1 && x[i-1]==1 && t[i]==1 && x[i]==0 --> t[i]:=1; x[i]:=2; )
    ( t[i-1]==1 && x[i-1]==1 && t[i]==1 && x[i]==1 --> t[i]:=0; x[i]:=1; )
    ( t[i-1]==1 && x[i-1]==2 && t[i]==0 && x[i]==0 --> t[i]:=0; x[i]:=2; )
    ( t[i-1]==1 && x[i-1]==2 && t[i]==0 && x[i]==1 --> t[i]:=0; x[i]:=2; )
    ( t[i-1]==1 && x[i-1]==2 && t[i]==1 && x[i]==2 --> t[i]:=0; x[i]:=2; )
    // Add a fallback transition to handle deadlock states
    ( true --> t[i]:=1 - t[i-1]; x[i]:=(x[i-1] + 1) % M; )
    ;
}

// Process P (operates on nodes 1 to N-1)
process P[j <- Nat % (N-1)]
{
  let i := j + 1;  // i = 1, 2, 3, 4
  read: t[i-1];
  read: x[i-1];
  write: t[i];
  write: x[i];
  direct action:
    // Define transitions for P process based on t[i-1], x[i-1], t[i], x[i]
    ( t[i-1]==0 && x[i-1]==0 && t[i]==0 && x[i]==0 --> t[i]:=0; x[i]:=1; )
    ( t[i-1]==0 && x[i-1]==0 && t[i]==0 && x[i]==2 --> t[i]:=0; x[i]:=1; )
    ( t[i-1]==0 && x[i-1]==0 && t[i]==1 && x[i]==2 --> t[i]:=1; x[i]:=0; )
    ( t[i-1]==0 && x[i-1]==1 && t[i]==0 && x[i]==0 --> t[i]:=0; x[i]:=1; )
    ( t[i-1]==0 && x[i-1]==1 && t[i]==0 && x[i]==2 --> t[i]:=0; x[i]:=1; )
    ( t[i-1]==0 && x[i-1]==1 && t[i]==1 && x[i]==0 --> t[i]:=0; x[i]:=1; )
    ( t[i-1]==0 && x[i-1]==1 && t[i]==1 && x[i]==1 --> t[i]:=0; x[i]:=1; )
    ( t[i-1]==0 && x[i-1]==1 && t[i]==1 && x[i]==2 --> t[i]:=0; x[i]:=1; )
    ( t[i-1]==0 && x[i-1]==2 && t[i]==0 && x[i]==0 --> t[i]:=0; x[i]:=2; )
    ( t[i-1]==0 && x[i-1]==2 && t[i]==0 && x[i]==1 --> t[i]:=0; x[i]:=2; )
    ( t[i-1]==0 && x[i-1]==2 && t[i]==1 && x[i]==0 --> t[i]:=0; x[i]:=2; )
    ( t[i-1]==0 && x[i-1]==2 && t[i]==1 && x[i]==1 --> t[i]:=0; x[i]:=2; )
    ( t[i-1]==0 && x[i-1]==2 && t[i]==1 && x[i]==2 --> t[i]:=0; x[i]:=2; )
    ( t[i-1]==1 && x[i-1]==0 && t[i]==0 && x[i]==0 --> t[i]:=1; x[i]:=0; )
    ( t[i-1]==1 && x[i-1]==0 && t[i]==0 && x[i]==1 --> t[i]:=1; x[i]:=1; )
    ( t[i-1]==1 && x[i-1]==0 && t[i]==0 && x[i]==2 --> t[i]:=1; x[i]:=1; )
    ( t[i-1]==1 && x[i-1]==0 && t[i]==1 && x[i]==2 --> t[i]:=1; x[i]:=1; )
    ( t[i-1]==1 && x[i-1]==1 && t[i]==0 && x[i]==2 --> t[i]:=0; x[i]:=0; )
    ( t[i-1]==1 && x[i-1]==1 && t[i]==1 && x[i]==2 --> t[i]:=1; x[i]:=0; )
    ( t[i-1]==1 && x[i-1]==2 && t[i]==0 && x[i]==0 --> t[i]:=1; x[i]:=2; )
    ( t[i-1]==1 && x[i-1]==2 && t[i]==0 && x[i]==1 --> t[i]:=0; x[i]:=2; )
    ( t[i-1]==1 && x[i-1]==2 && t[i]==1 && x[i]==0 --> t[i]:=1; x[i]:=2; )
    ( t[i-1]==1 && x[i-1]==2 && t[i]==1 && x[i]==1 --> t[i]:=1; x[i]:=2; )
    // Add a fallback transition to handle deadlock states
    ( true --> t[i]:=t[i-1]; x[i]:=(x[i-1] + 1) % M; )
    ;
}

// One process is enabled to act.
// The "active shadow" ensures that the protocol is live.
(future & active shadow)
  (unique i <- Nat % N :
   i == 0 &&
   (false
    || t[i-1]==0 && x[i-1]==0 && t[i]==0 && x[i]==0
    || t[i-1]==0 && x[i-1]==0 && t[i]==1 && x[i]==0
    || t[i-1]==0 && x[i-1]==0 && t[i]==1 && x[i]==1
    || t[i-1]==0 && x[i-1]==1 && t[i]==0 && x[i]==0
    || t[i-1]==0 && x[i-1]==1 && t[i]==0 && x[i]==1
    || t[i-1]==0 && x[i-1]==1 && t[i]==1 && x[i]==0
    || t[i-1]==0 && x[i-1]==1 && t[i]==1 && x[i]==1
    || t[i-1]==0 && x[i-1]==2 && t[i]==0 && x[i]==0
    || t[i-1]==0 && x[i-1]==2 && t[i]==0 && x[i]==1
    || t[i-1]==0 && x[i-1]==2 && t[i]==0 && x[i]==2
    || t[i-1]==0 && x[i-1]==2 && t[i]==1 && x[i]==2
    || t[i-1]==1 && x[i-1]==0 && t[i]==0 && x[i]==0
    || t[i-1]==1 && x[i-1]==0 && t[i]==1 && x[i]==0
    || t[i-1]==1 && x[i-1]==0 && t[i]==1 && x[i]==1
    || t[i-1]==1 && x[i-1]==1 && t[i]==0 && x[i]==0
    || t[i-1]==1 && x[i-1]==1 && t[i]==1 && x[i]==0
    || t[i-1]==1 && x[i-1]==1 && t[i]==1 && x[i]==1
    || t[i-1]==1 && x[i-1]==2 && t[i]==0 && x[i]==0
    || t[i-1]==1 && x[i-1]==2 && t[i]==0 && x[i]==1
    || t[i-1]==1 && x[i-1]==2 && t[i]==1 && x[i]==2
   )
   ||
   i != 0 &&
   (false
    || t[i-1]==0 && x[i-1]==0 && t[i]==0 && x[i]==0
    || t[i-1]==0 && x[i-1]==0 && t[i]==0 && x[i]==2
    || t[i-1]==0 && x[i-1]==0 && t[i]==1 && x[i]==2
    || t[i-1]==0 && x[i-1]==1 && t[i]==0 && x[i]==0
    || t[i-1]==0 && x[i-1]==1 && t[i]==0 && x[i]==2
    || t[i-1]==0 && x[i-1]==1 && t[i]==1 && x[i]==0
    || t[i-1]==0 && x[i-1]==1 && t[i]==1 && x[i]==1
    || t[i-1]==0 && x[i-1]==1 && t[i]==1 && x[i]==2
    || t[i-1]==0 && x[i-1]==2 && t[i]==0 && x[i]==0
    || t[i-1]==0 && x[i-1]==2 && t[i]==0 && x[i]==1
    || t[i-1]==0 && x[i-1]==2 && t[i]==1 && x[i]==0
    || t[i-1]==0 && x[i-1]==2 && t[i]==1 && x[i]==1
    || t[i-1]==0 && x[i-1]==2 && t[i]==1 && x[i]==2
    || t[i-1]==1 && x[i-1]==0 && t[i]==0 && x[i]==0
    || t[i-1]==1 && x[i-1]==0 && t[i]==0 && x[i]==1
    || t[i-1]==1 && x[i-1]==0 && t[i]==0 && x[i]==2
    || t[i-1]==1 && x[i-1]==0 && t[i]==1 && x[i]==2
    || t[i-1]==1 && x[i-1]==1 && t[i]==0 && x[i]==2
    || t[i-1]==1 && x[i-1]==1 && t[i]==1 && x[i]==2
    || t[i-1]==1 && x[i-1]==2 && t[i]==0 && x[i]==0
    || t[i-1]==1 && x[i-1]==2 && t[i]==0 && x[i]==1
    || t[i-1]==1 && x[i-1]==2 && t[i]==1 && x[i]==0
    || t[i-1]==1 && x[i-1]==2 && t[i]==1 && x[i]==1
   )
  );